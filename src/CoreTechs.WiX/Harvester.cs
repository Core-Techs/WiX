using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Xsl;
using CoreTechs.Common;

namespace CoreTechs.WiX
{
    public class Harvester
    {
        private readonly List<Func<File, bool>> _exclusions = new List<Func<File, bool>>();
        private readonly List<Action<Component, XElement>> _mods = new List<Action<Component, XElement>>();

        /// <summary>
        /// File names that will always be included. Overrides excluded extensions.
        /// </summary>
        public IList<string> IncludeFiles { get; set; }

        /// <summary>
        /// File extensions that will be excluded.
        /// </summary>
        public IList<string> ExcludeExtensions { get; set; }

        /// <summary>
        /// The directory to get files from.
        /// </summary>
        public DirectoryInfo Directory { get; private set; }

        /// <summary>
        /// The Id to be given to the generated DirectoryRef element.
        /// </summary>
        public string DirectoryRefId { get; private set; }

        /// <summary>
        /// The Id to be given to the generated ComponentGroup element.
        /// </summary>
        public string ComponentGroupId { get; private set; }

        /// <summary>
        /// Transformation file to apply after harvesting.
        /// </summary>
        public string XSLTFilePath { get; set; }

        /// <summary>
        /// Used to determine what file system paths are relative to.
        /// </summary>
        public FileSystemInfo WxsDestination { get; set; }

        /// <summary>
        /// Transformation to apply after harvesting.
        /// </summary>
        public ITransformation Transformation { get; set; }

        public Harvester(string directoryPath, string wxsDestinationFilePath, string directoryRefId, string componentGroupId)
        {
            if (directoryPath == null) throw new ArgumentNullException("directoryPath");
            if (wxsDestinationFilePath == null) throw new ArgumentNullException("wxsDestinationFilePath");
            if (directoryRefId == null) throw new ArgumentNullException("directoryRefId");
            if (componentGroupId == null) throw new ArgumentNullException("componentGroupId");

            Directory = new DirectoryInfo(directoryPath);
            WxsDestination = new FileInfo(wxsDestinationFilePath);
            DirectoryRefId = directoryRefId;
            ComponentGroupId = componentGroupId;
        }

        /// <summary>
        /// Generates Wix XML.
        /// </summary>
        public XDocument Harvest()
        {
            var ns = Constants.WixNs;

            var directoryRef = new XElement(ns + "DirectoryRef",
                new XAttribute("Id", DirectoryRefId),
                new XAttribute("FileSource", WxsDestination.GetRelativePathTo(Directory)));

            var componentGroup = new XElement(ns + "ComponentGroup",
                new XAttribute("Id", ComponentGroupId));

            foreach (var component in GetComponents())
            {
                var compXel = component.InjectXml(directoryRef);

                componentGroup.Add(
                    new XComment(component.File.PathRelativeToRoot),
                    new XElement(ns + "ComponentRef",
                        new XAttribute("Id", component.Id)));

                foreach (var mod in _mods)
                    mod(component, compXel);
            }

            var fragment = new XElement(ns + "Fragment", directoryRef, componentGroup);
            var wix = new XElement(ns + "Wix", fragment);
            var xml = new XDocument(
                new XComment("Automatically generated by " + GetType().Assembly.GetName().Name),
                wix);

            if (!XSLTFilePath.IsNullOrWhiteSpace())
                xml = ApplyXSLT(xml);

            if (Transformation != null)
                xml = Transformation.Transform(xml);

            return xml;
        }

        private IEnumerable<Func<File, bool>> GetDefaultExclusions()
        {
            yield return
                f =>
                {
                    if (IncludeFiles != null && IncludeFiles.Contains(f.Info.Name, StringComparer.OrdinalIgnoreCase))
                        return false;

                    return ExcludeExtensions != null &&
                           ExcludeExtensions.Any(
                               ext =>
                                   f.Info.Name.EndsWith(ext.StartsWith(".") ? ext : "." + ext,
                                       StringComparison.OrdinalIgnoreCase));
                };
        }

        private XDocument ApplyXSLT(XDocument xml)
        {
            // ensure xslt file exists
            var xsltFile = new FileInfo(XSLTFilePath);
            if (!xsltFile.Exists)
                throw new FileNotFoundException("The xslt file could not be found: " + XSLTFilePath);

            // apply transformation
            var newXml = new XDocument();
            using (var writer = newXml.CreateWriter())
            {
                // Load the XSLT
                var xslt = new XslCompiledTransform();
                using (var fileStream = xsltFile.OpenRead())
                using (var streamReader = new StreamReader(fileStream))
                    xslt.Load(XmlReader.Create(streamReader));

                // Execute the transform and output the results to a writer.
                using (var xmlReader = xml.CreateReader())
                    xslt.Transform(xmlReader, writer);
            }

            return newXml;
        }

        private IEnumerable<Component> GetComponents()
        {
            var exclusions = GetDefaultExclusions().Concat(_exclusions);

            return Directory
                .EnumerateFiles("*", SearchOption.AllDirectories)
                .Select(f => new File(f, this))
                .WhereNot(f => exclusions.Any(x => x(f)))
                .Select(x => new Component(x, this));
        }

        public Harvester ExcludeWhere(Func<File, bool> predicate)
        {
            _exclusions.Add(predicate);
            return this;
        }

        /// <summary>
        /// Allows the developer to modify a Component's xml.
        /// </summary>
        /// <param name="predicate">The condition in which the modification action will be invoked.</param>
        /// <param name="modification">The modification action.</param>
        public Harvester ModifyComponentsWhere(Func<Component, bool> predicate, Action<Component, XElement> modification)
        {
            if (predicate == null) throw new ArgumentNullException("predicate");
            if (modification == null) throw new ArgumentNullException("modification");

            return ModifyComponents((c, xe) =>
            {
                if (predicate(c))
                    modification(c, xe);
            });
        }

        /// <summary>
        /// Allows the developer to modify a Component's xml.
        /// </summary>
        /// <param name="modification">The modification action.</param>
        public Harvester ModifyComponents(Action<Component, XElement> modification)
        {
            if (modification == null) throw new ArgumentNullException("modification");
            _mods.Add(modification);
            return this;
        }
    }
}